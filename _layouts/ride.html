<!DOCTYPE html>
<html lang="en-us">
    {% include head.html %}
<head>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/geohash"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-polylinedecorator/1.1.0/leaflet.polylineDecorator.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/protobufjs@latest/dist/protobuf.min.js"></script>
  <style>
    #map { height: 50em;
      width: 100em;}
  </style>
</head>



<body>
    <div class="imageWrapper">
                    <div class="appInfo">
                        <div class="appIconShadow">
                            <svg width="0" height="0">
                                <defs>
                                    <clipPath id="shape120">
                                        <path id="shape" class="cls-1" d="M6821,495.533v-4.281c0-1.2-.04-2.4-0.04-3.642a57.7,57.7,0,0,0-.68-7.882,26.144,26.144,0,0,0-2.48-7.483,25.115,25.115,0,0,0-11.04-11.044,26.118,26.118,0,0,0-7.49-2.481,47.28,47.28,0,0,0-7.88-.68c-1.2-.04-2.4-0.04-3.64-0.04h-53.5c-1.2,0-2.4.04-3.64,0.04a57.813,57.813,0,0,0-7.88.68,26.323,26.323,0,0,0-7.49,2.481,25.115,25.115,0,0,0-11.04,11.044,26.144,26.144,0,0,0-2.48,7.483,47.313,47.313,0,0,0-.68,7.882c-0.04,1.2-.04,2.4-0.04,3.642v53.5c0,1.2.04,2.4,0.04,3.641a57.7,57.7,0,0,0,.68,7.883,26.137,26.137,0,0,0,2.48,7.482,25.115,25.115,0,0,0,11.04,11.044,26.261,26.261,0,0,0,7.49,2.481,47.28,47.28,0,0,0,7.88.68c1.2,0.04,2.4.04,3.64,0.04h53.5c1.2,0,2.4-.04,3.64-0.04a57.654,57.654,0,0,0,7.88-.68,26.057,26.057,0,0,0,7.49-2.481,25.115,25.115,0,0,0,11.04-11.044,26.137,26.137,0,0,0,2.48-7.482,47.316,47.316,0,0,0,.68-7.883c0.04-1.2.04-2.4,0.04-3.641V495.533h0Z" transform="translate(-6701 -458)" filter="url(#f1)"/>
                                    </clipPath>
                                </defs>
                            </svg>
                            {% if site.qr_code %}
                                <img class="qrCode" src="{{site.qr_code}}">
                            {%else%}
                                <img class="appIconLarge" src="{{ site.app_icon | relative_url }}">
                            {% endif %}
                        </div>
                        <div class="appNamePriceContainer">
                            <h1 class="appName">
                                {{ site.app_name }}
                            </h1>
                            <h2 class="appPrice">
                                {{ site.app_price }}
                            </h2>
                        </div>
                        <div class="appDescriptionContainer">
                            <p class ="appDescription">
                                {{ site.app_description }}
                            </p>
                        </div>
                        <div class="downloadButtonsContainer">
                            {% if site.playstore_link %}
                                <a class="playStoreLink" href="{{site.playstore_link}}"><img class="playStore" src="/assets/playstore.png"></a>
                            {% endif %}
                            {% if site.appstore_link %}
                                <a class="appStoreLink" href="{{site.appstore_link}}"><img class="appStore" src="/assets/appstore.png"></a>                        </div>
                            {% endif %}
                        </div>
                    </div>
                <div id="map"></div>
            </div>
    <script>
const protoSchema = `
syntax = "proto3";

package giggossipframes;
option csharp_namespace = "GigGossip";

message UUID
{
  bytes Value = 1;
}

message Timestamp
{
  int64 Value = 1;
}

message URI
{
    string Value = 1;
}

message Signature
{
    bytes Value = 1;
}

message PublicKey
{
    bytes Value = 1;
}

message PaymentRequest
{
    string Value = 1;
}

message PaymentHash
{
    bytes Value = 1;
}

message Satoshis
{
    int64 Value = 1;
}

message EncryptedData
{
    bytes Value = 1;
}

message CryptographicHash
{
    bytes Value = 1;
}

message AuthTokenHeader
{
  UUID TokenId = 1;
  PublicKey PublicKey = 2;
  Timestamp Timestamp = 3;
}

/// <summary>
/// A struct to represent a timed GUID token with its signature. Used in API calls.
/// </summary>
message AuthToken
{
    AuthTokenHeader Header = 1;
    Signature Signature = 2;
}

message CertificateProperty
{
    string Name = 1;
    bytes Value = 2;
}

message CertificateHeader
{
    /// <summary>
    /// The Uri of the Certification Authority service
    /// </summary>
    URI AuthorityUri = 1;

    /// <summary>
    /// Collection of certified properties of the Subject
    /// </summary>
    repeated CertificateProperty Properties = 2;

    /// <summary>
    /// Date and Time before which the Certificate will no longer be valid
    /// </summary>
    Timestamp NotValidAfter = 3;

    /// <summary>
    /// Date and Time before which the Certificate is not yet valid
    /// </summary>
    Timestamp NotValidBefore = 4;
}

/// <summary>
/// Represents a layer in the Onion routing protocol, which contains a public key and encrypted data core.
/// </summary>
message OnionLayer
{
    /// <summary>
    /// Gets or sets the public key associated with this layer of the onion route.
    /// </summary>
    PublicKey PublicKey = 1;

    /// <summary>
    /// Gets or sets the encrypted core of the onion layer.
    /// </summary>
    EncryptedData EncryptedOnionLayer = 2;
}


/// <summary>
/// An onion route is used in the onion routing protocol to establish an anonymous communication channel.
/// Each "onion" in the route is peeled back one at a time by each gig gossip node in the network.
/// </summary>
message Onion
{
    /// <summary>
    /// An array of bytes representing the "Onion", the data passed through the route.
    /// </summary>
    EncryptedData EncryptedOnionLayer = 1;
}

/// <summary>
/// Represents a broadcast frame in proof of work (POW) which contains the broadcast payload and the work proof.
/// </summary>
message BroadcastFrame
{
    /// <summary>
    /// Gets or sets the signed payload for the request. This contains the necessary data for processing the request.
    /// </summary>
    JobRequest JobRequest = 1;

    /// <summary>
    /// Gets or sets the Onion Route used for back-routing of the message.
    /// </summary>
    Onion BackwardOnion = 2;
}

message CancelBroadcastFrame
{
    CancelJobRequest CancelJobRequest = 1;
}

message CancelJobRequestHeader
{
    CertificateHeader Header = 1;
    UUID JobRequestId = 2;
    Timestamp Timestamp = 3;
}

message CancelJobRequest
{
    CancelJobRequestHeader Header = 1;
    Signature Signature = 2;
}

message BroadcastRequest
{
    JobRequest JobRequest = 1;
    CancelJobRequest CancelJobRequest = 2;
}

/// <summary>
/// Represents a reply frame that contains encrypted payload, settlement promise, onion route and network PaymentRequest.
/// </summary>
message ReplyFrame
{
    /// <summary>
    /// Gets or sets the encrypted reply payload.
    /// </summary>
    EncryptedData EncryptedJobReply = 1;

    /// <summary>
    /// Gets or sets the signed settlement promise.
    /// </summary>
    /// <see cref="SettlementPromise"/>
    SettlementPromise SettlementPromise = 2;

    /// <summary>
    /// Gets or sets the forward onion route.
    /// </summary>
    /// <see cref="OnionRoute"/>
    Onion ForwardOnion = 3;

    /// <summary>
    /// Gets or sets the network PaymentRequest.
    /// </summary>
    PaymentRequest NetworkPaymentRequest = 4;
}


message JobReplyHeader
{
    CertificateHeader Header = 1;
    UUID JobReplyId = 2;
    /// <summary>
    /// Gets or sets the signed request payload.
    /// </summary>
    JobRequest JobRequest = 3;

    /// <summary>
    /// Gets or sets the encrypted reply message.
    /// </summary>
    EncryptedData EncryptedReply = 4;

    /// <summary>
    /// Gets or sets the reply PaymentRequest.
    /// </summary>
    PaymentRequest JobPaymentRequest = 5;

    /// <summary>
    /// Gets or sets creation timestamp of the payload.
    /// </summary>
    Timestamp Timestamp = 6;
}

/// <summary>
/// Represents the payload of a reply message.
/// </summary>
message JobReply
{
    JobReplyHeader Header = 1;
    Signature Signature = 2;
}

message Reply
{
    oneof Value
    {
        bytes Unknown = 1;
        RideShareReply RideShare = 2;
    }
}

message JobRequestHeader
{
    CertificateHeader Header = 1;
    UUID JobRequestId = 2;
    /// <summary>
    /// Gets or sets creation timestamp of the payload.
    /// </summary>
    Timestamp Timestamp = 3;

    /// <summary>
    /// Gets or sets the topic of the payload.
    /// </summary>
    oneof Topic
    {
        bytes Unknown = 4;
        RideShareTopic RideShare = 5;
    }
}

/// <summary>
/// Represents the payload of a request message.
/// </summary>
message JobRequest
{
    JobRequestHeader Header = 1;
    Signature Signature = 2;
}

message SettlementPromiseHeader
{

    /// <summary>
    /// Gets or sets the service URI of the Settler.
    /// </summary>

    URI MySecurityCenterUri = 1;

    /// <summary>
    /// Gets or sets the service URI of the Requester Settler.
    /// </summary>
    URI TheirSecurityCenterUri = 2;

    /// <summary>
    /// Gets or sets the network payment hash.
    /// </summary>
    PaymentHash NetworkPaymentHash = 3;

    CryptographicHash HashOfEncryptedJobReply = 4;

    /// <summary>
    /// Gets or sets the reply payment amount.
    /// </summary>
    Satoshis ReplyPaymentAmount = 5;
}

/// <summary>
/// Represents a settlement promise.
/// </summary>
message SettlementPromise
{
    SettlementPromiseHeader Header = 1;
    Signature Signature = 2;
}

message SettlementTrust
{
    /// <summary>
    /// Gets or sets the settlement promise.
    /// </summary>
    /// <see cref="SettlementPromise"/>
    SettlementPromise SettlementPromise = 1;

    /// <summary>
    /// Gets or sets the network PaymentRequest.
    /// </summary>
    PaymentRequest NetworkPaymentRequest = 2;

    /// <summary>
    /// Gets or sets the encrypted reply payload.
    /// </summary>
    EncryptedData EncryptedJobReply = 3;

    UUID JobReplyId = 4;
}

message Frame
{
    oneof Value
    {
        BroadcastFrame Broadcast = 1;
        CancelBroadcastFrame CancelBroadcast = 2;
        ReplyFrame Reply = 3;
        LocationFrame Location = 4;
    }
}


//// RIDESHARE


message GeoLocation
{
    double Latitude = 1;
    double Longitude = 2;
}

message RideShareTopic
{
    string FromGeohash = 1;
    string ToGeohash = 2;
    Timestamp PickupAfter = 3;
    Timestamp PickupBefore = 4;
    double Distance = 5;
    string Currency = 6;
    string Country = 7;
}

message RideShareReply
{
    PublicKey PublicKey = 1;
    repeated URI Relays = 2;
    string Secret = 3;
    GeoLocation Location = 4;
    string Message = 5;
}

enum RideState
{
    Started = 0;
    DriverGoingForRider = 1;
    DriverWaitingForRider = 2;
    RiderPickedUp = 3;
    DriverGoingWithRider = 4;
    Completed = 5;
    Disputed = 6;
    Failed = 7;
    Cancelled = 8;
    Scheduled = 9;
}

message LocationFrame
{
    UUID JobRequestId = 1;
    UUID JobReplyId = 2;
    URI SecurityCenterUri = 3;
    string Secret = 4;
    GeoLocation FromLocation = 5;
    GeoLocation ToLocation = 6;
    string FromAddress = 7;
    string ToAddress = 8;
    GeoLocation Location = 9;
    string Message = 10;
    RideState RideStatus = 11;
}`;
  protobuf.parse(protoSchema, { keepCase: true }).root.resolveAll();
  const Message = protobuf.Root.fromJSON(protobuf.parse(protoSchema).root).lookupType("JobRequest");
  let params = new URLSearchParams(location.search);
  let url = ("https://giggossip.blob.core.windows.net/gohyper/"+params);
  console.log(url.slice(0, -1));
  let result;
  fetch(url.slice(0, -1))
          .then(response => response.arrayBuffer())
          .then(arrayBuffer => {
            const buffer = new Uint8Array(arrayBuffer);
            const message = Message.decode(buffer);
            result=message.Header.RideShare;
          })
          .catch(error => {
            console.error('Error fetching the data:', error);
          });
  setTimeout(() => {
    const geohashPunkt1 = result.FromGeohash;
    const geohashPunkt2 = result.ToGeohash;
    const coordPunkt1 = decodeGeohash(geohashPunkt1);
    const coordPunkt2 = decodeGeohash(geohashPunkt2);
    console.log(coordPunkt1);
    console.log(coordPunkt2);

    const map = L.map('map').setView([(coordPunkt1.lat+coordPunkt2.lat)/2, (coordPunkt1.lon+coordPunkt2.lon)/2], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: ' OpenStreetMap contributors'
    }).addTo(map);

    const markerPunkt1 = L.circle([coordPunkt1.lat, coordPunkt1.lon], {radius: 200}).addTo(map);
    const popupPunkt1 = L.popup().setLatLng([coordPunkt1.lat, coordPunkt1.lon]).setContent("Rider: " + geohashPunkt1);
    markerPunkt1.bindPopup(popupPunkt1).openPopup();

    const markerPunkt2 = L.circle([coordPunkt2.lat, coordPunkt2.lon], {radius: 200}).addTo(map);
    const popupPunkt2 = L.popup().setLatLng([coordPunkt2.lat, coordPunkt2.lon]).setContent("Destination: " + geohashPunkt2);
    markerPunkt2.bindPopup(popupPunkt2);

    const polyline = L.polyline([[coordPunkt1.lat, coordPunkt1.lon], [coordPunkt2.lat, coordPunkt2.lon]], {
      color: 'red',
      weight: 3,
      opacity: 0.5,
      lineCap: 'round',
      lineJoin: 'round',
      dashArray: [20, 10],
      dashOffset: 20
    }).addTo(map);

    L.polylineDecorator(polyline, {
      patterns: [
        {offset: '0%', repeat: 75, symbol: L.Symbol.arrowHead({pixelSize: 40, pathOptions: {fillOpacity: 0.75, weight: 0}})}
      ]
    }).addTo(map);
  }, 100);

  function decodeGeohash(geohash) {
    const decoded = GeoHash.decodeGeoHash(geohash);
    return { lat: decoded.latitude[2], lon: decoded.longitude[2] };
  }
</script>
</body>
</html>
